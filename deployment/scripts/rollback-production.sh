#!/bin/bash\n# Aurigraph V11 Production Rollback Script\n# Provides safe rollback procedures with validation and monitoring\n\nset -euo pipefail\n\n# =============================================================================\n# Configuration\n# =============================================================================\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nTIMESTAMP=\"$(date '+%Y%m%d-%H%M%S')\"\nROLLBACK_LOG=\"${PROJECT_ROOT}/logs/rollback-${TIMESTAMP}.log\"\n\n# Create logs directory\nmkdir -p \"${PROJECT_ROOT}/logs\"\n\n# Default configuration\nNAMESPACE=\"aurigraph-production\"\nDEPLOYMENT_NAME=\"aurigraph-v11-production\"\nKUBE_CONTEXT=\"${KUBE_CONTEXT:-production}\"\nROLLBACK_TIMEOUT=\"600\"  # 10 minutes\nHEALTH_CHECK_TIMEOUT=\"300\"  # 5 minutes\nVERIFICATION_TIMEOUT=\"120\"  # 2 minutes\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\n# =============================================================================\n# Logging Functions\n# =============================================================================\n\nlog_info() {\n    echo -e \"${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" | tee -a \"$ROLLBACK_LOG\"\n}\n\nlog_success() {\n    echo -e \"${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" | tee -a \"$ROLLBACK_LOG\"\n}\n\nlog_warn() {\n    echo -e \"${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" | tee -a \"$ROLLBACK_LOG\"\n}\n\nlog_error() {\n    echo -e \"${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*\" | tee -a \"$ROLLBACK_LOG\"\n}\n\n# =============================================================================\n# Utility Functions\n# =============================================================================\n\ncheck_prerequisites() {\n    log_info \"Checking rollback prerequisites...\"\n    \n    # Check required commands\n    for cmd in kubectl jq curl; do\n        if ! command -v \"$cmd\" &> /dev/null; then\n            log_error \"Required command '$cmd' not found\"\n            exit 1\n        fi\n    done\n    \n    # Check Kubernetes context\n    if ! kubectl config get-contexts \"$KUBE_CONTEXT\" &> /dev/null; then\n        log_error \"Kubernetes context '$KUBE_CONTEXT' not found\"\n        exit 1\n    fi\n    \n    kubectl config use-context \"$KUBE_CONTEXT\"\n    \n    # Verify cluster connectivity\n    if ! kubectl cluster-info &> /dev/null; then\n        log_error \"Cannot connect to Kubernetes cluster\"\n        exit 1\n    fi\n    \n    # Check if deployment exists\n    if ! kubectl get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" &> /dev/null; then\n        log_error \"Deployment '$DEPLOYMENT_NAME' not found in namespace '$NAMESPACE'\"\n        exit 1\n    fi\n    \n    log_success \"Prerequisites check completed\"\n}\n\nget_deployment_history() {\n    log_info \"Retrieving deployment history...\"\n    \n    local history_output\n    history_output=$(kubectl rollout history deployment/$DEPLOYMENT_NAME -n \"$NAMESPACE\" 2>/dev/null || true)\n    \n    if [[ -z \"$history_output\" ]]; then\n        log_error \"No deployment history found\"\n        exit 1\n    fi\n    \n    echo \"$history_output\"\n}\n\nget_current_revision() {\n    kubectl get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" -o jsonpath='{.metadata.annotations.deployment\\.kubernetes\\.io/revision}'\n}\n\nget_previous_revision() {\n    local current_revision\n    current_revision=$(get_current_revision)\n    \n    if [[ -z \"$current_revision\" ]] || [[ ! \"$current_revision\" =~ ^[0-9]+$ ]]; then\n        log_error \"Cannot determine current revision\"\n        return 1\n    fi\n    \n    local previous_revision=$((current_revision - 1))\n    \n    # Verify the previous revision exists\n    if kubectl rollout history deployment/$DEPLOYMENT_NAME -n \"$NAMESPACE\" --revision=\"$previous_revision\" &> /dev/null; then\n        echo \"$previous_revision\"\n    else\n        log_error \"Previous revision $previous_revision not found\"\n        return 1\n    fi\n}\n\nget_revision_info() {\n    local revision=\"$1\"\n    kubectl rollout history deployment/$DEPLOYMENT_NAME -n \"$NAMESPACE\" --revision=\"$revision\" 2>/dev/null || true\n}\n\ncapture_current_state() {\n    log_info \"Capturing current deployment state...\"\n    \n    local state_file=\"${PROJECT_ROOT}/logs/pre-rollback-state-${TIMESTAMP}.json\"\n    \n    # Capture deployment state\n    kubectl get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" -o json > \"$state_file\"\n    \n    # Capture pod states\n    kubectl get pods -l app=aurigraph-v11 -n \"$NAMESPACE\" -o json >> \"$state_file\"\n    \n    # Capture HPA state\n    kubectl get hpa aurigraph-v11-production-hpa -n \"$NAMESPACE\" -o json >> \"$state_file\" 2>/dev/null || true\n    \n    log_success \"Current state captured to: $state_file\"\n}\n\nperform_health_check() {\n    local timeout=\"${1:-$HEALTH_CHECK_TIMEOUT}\"\n    log_info \"Performing health check (timeout: ${timeout}s)...\"\n    \n    # Wait for pods to be ready\n    if kubectl wait --for=condition=ready pod \\\n        -l app=aurigraph-v11 \\\n        -n \"$NAMESPACE\" \\\n        --timeout=\"${timeout}s\"; then\n        \n        log_success \"All pods are ready\"\n    else\n        log_error \"Health check failed - not all pods are ready\"\n        return 1\n    fi\n    \n    # Test application endpoints\n    log_info \"Testing application endpoints...\"\n    \n    # Get a pod for endpoint testing\n    local pod_name\n    pod_name=$(kubectl get pods -l app=aurigraph-v11 -n \"$NAMESPACE\" -o jsonpath='{.items[0].metadata.name}')\n    \n    if [[ -n \"$pod_name\" ]]; then\n        # Test health endpoint\n        if kubectl exec \"$pod_name\" -n \"$NAMESPACE\" -c aurigraph-v11-production -- \\\n            curl -sf http://localhost:9003/q/health/ready > /dev/null; then\n            log_success \"Health endpoint responding correctly\"\n        else\n            log_error \"Health endpoint not responding\"\n            return 1\n        fi\n        \n        # Test performance endpoint\n        if kubectl exec \"$pod_name\" -n \"$NAMESPACE\" -c aurigraph-v11-production -- \\\n            curl -sf http://localhost:9003/api/v11/performance > /dev/null; then\n            log_success \"Performance endpoint responding correctly\"\n        else\n            log_warn \"Performance endpoint not responding - may need warm-up time\"\n        fi\n    else\n        log_error \"No pods found for endpoint testing\"\n        return 1\n    fi\n    \n    log_success \"Health check completed successfully\"\n}\n\nverify_performance() {\n    log_info \"Verifying post-rollback performance...\"\n    \n    # Allow warm-up time\n    log_info \"Allowing 30s warm-up time...\"\n    sleep 30\n    \n    # Check HPA metrics\n    log_info \"Checking HPA metrics...\"\n    kubectl get hpa aurigraph-v11-production-hpa -n \"$NAMESPACE\" -o wide 2>/dev/null || true\n    \n    # Basic performance validation\n    local pod_name\n    pod_name=$(kubectl get pods -l app=aurigraph-v11 -n \"$NAMESPACE\" -o jsonpath='{.items[0].metadata.name}')\n    \n    if [[ -n \"$pod_name\" ]]; then\n        log_info \"Testing basic transaction processing...\"\n        if kubectl exec \"$pod_name\" -n \"$NAMESPACE\" -c aurigraph-v11-production -- \\\n            timeout 10 curl -sf http://localhost:9003/api/v11/stats > /dev/null 2>&1; then\n            log_success \"Basic performance validation passed\"\n        else\n            log_warn \"Performance validation inconclusive - monitoring recommended\"\n        fi\n    fi\n    \n    log_success \"Performance verification completed\"\n}\n\nsend_rollback_notification() {\n    local status=\"$1\"\n    local message=\"$2\"\n    local revision=\"${3:-unknown}\"\n    \n    log_info \"Sending rollback notification...\"\n    \n    # Slack notification\n    if [[ -n \"${SLACK_WEBHOOK_URL:-}\" ]]; then\n        local color=\"good\"\n        [[ \"$status\" != \"success\" ]] && color=\"danger\"\n        \n        curl -X POST -H 'Content-type: application/json' \\\n            --data '{\n                \"attachments\": [{\n                    \"color\": \"'$color'\",\n                    \"title\": \"Aurigraph V11 Production Rollback\",\n                    \"text\": \"'$message'\",\n                    \"fields\": [\n                        {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true},\n                        {\"title\": \"Namespace\", \"value\": \"'$NAMESPACE'\", \"short\": true},\n                        {\"title\": \"Revision\", \"value\": \"'$revision'\", \"short\": true},\n                        {\"title\": \"Timestamp\", \"value\": \"'$TIMESTAMP'\", \"short\": true}\n                    ],\n                    \"footer\": \"Aurigraph V11 Rollback\",\n                    \"ts\": '$(date +%s)'\n                }]\n            }' \\\n            \"$SLACK_WEBHOOK_URL\" 2>/dev/null || true\n    fi\n    \n    # Email notification\n    if [[ -n \"${NOTIFICATION_EMAIL:-}\" ]] && command -v mail > /dev/null 2>&1; then\n        echo \"$message\" | mail -s \"Aurigraph V11 Production Rollback - $status\" \"$NOTIFICATION_EMAIL\" 2>/dev/null || true\n    fi\n}\n\n# =============================================================================\n# Rollback Functions\n# =============================================================================\n\nrollback_to_revision() {\n    local target_revision=\"$1\"\n    log_info \"Rolling back to revision $target_revision...\"\n    \n    local rollback_start=$(date +%s)\n    \n    # Initiate rollback\n    if kubectl rollout undo deployment/$DEPLOYMENT_NAME \\\n        -n \"$NAMESPACE\" \\\n        --to-revision=\"$target_revision\"; then\n        \n        log_success \"Rollback initiated to revision $target_revision\"\n    else\n        log_error \"Failed to initiate rollback\"\n        return 1\n    fi\n    \n    # Wait for rollback to complete\n    log_info \"Waiting for rollback to complete...\"\n    if kubectl rollout status deployment/$DEPLOYMENT_NAME \\\n        -n \"$NAMESPACE\" \\\n        --timeout=\"${ROLLBACK_TIMEOUT}s\"; then\n        \n        local rollback_end=$(date +%s)\n        local rollback_duration=$((rollback_end - rollback_start))\n        \n        log_success \"Rollback completed in ${rollback_duration}s\"\n        return 0\n    else\n        log_error \"Rollback failed or timed out\"\n        return 1\n    fi\n}\n\nrollback_to_previous() {\n    log_info \"Attempting rollback to previous revision...\"\n    \n    local previous_revision\n    if ! previous_revision=$(get_previous_revision); then\n        log_error \"Cannot determine previous revision\"\n        return 1\n    fi\n    \n    log_info \"Previous revision identified: $previous_revision\"\n    \n    # Show revision details\n    log_info \"Revision $previous_revision details:\"\n    get_revision_info \"$previous_revision\"\n    \n    rollback_to_revision \"$previous_revision\"\n}\n\ninteractive_rollback() {\n    log_info \"Interactive rollback mode\"\n    \n    echo -e \"\\n${YELLOW}=== Deployment History ===${NC}\"\n    get_deployment_history\n    \n    local current_revision\n    current_revision=$(get_current_revision)\n    echo -e \"\\n${BLUE}Current revision: $current_revision${NC}\"\n    \n    echo -e \"\\nAvailable rollback options:\"\n    echo \"1) Rollback to previous revision (automatic)\"\n    echo \"2) Rollback to specific revision (manual selection)\"\n    echo \"3) Show revision details\"\n    echo \"4) Cancel rollback\"\n    \n    read -p \"Select option (1-4): \" choice\n    \n    case $choice in\n        1)\n            rollback_to_previous\n            ;;\n        2)\n            read -p \"Enter revision number: \" target_revision\n            if [[ \"$target_revision\" =~ ^[0-9]+$ ]]; then\n                log_info \"Selected revision: $target_revision\"\n                get_revision_info \"$target_revision\"\n                read -p \"Confirm rollback to revision $target_revision? (y/N): \" confirm\n                if [[ \"$confirm\" =~ ^[Yy]$ ]]; then\n                    rollback_to_revision \"$target_revision\"\n                else\n                    log_info \"Rollback cancelled\"\n                    exit 0\n                fi\n            else\n                log_error \"Invalid revision number\"\n                exit 1\n            fi\n            ;;\n        3)\n            read -p \"Enter revision number for details: \" revision\n            if [[ \"$revision\" =~ ^[0-9]+$ ]]; then\n                get_revision_info \"$revision\"\n            else\n                log_error \"Invalid revision number\"\n            fi\n            interactive_rollback  # Return to menu\n            ;;\n        4)\n            log_info \"Rollback cancelled by user\"\n            exit 0\n            ;;\n        *)\n            log_error \"Invalid option selected\"\n            exit 1\n            ;;\n    esac\n}\n\n# =============================================================================\n# Main Rollback Process\n# =============================================================================\n\nmain() {\n    local target_revision=\"\"\n    local interactive_mode=false\n    local force_rollback=false\n    \n    # Parse command line arguments\n    while [[ $# -gt 0 ]]; do\n        case $1 in\n            --revision)\n                target_revision=\"$2\"\n                shift 2\n                ;;\n            --namespace)\n                NAMESPACE=\"$2\"\n                shift 2\n                ;;\n            --context)\n                KUBE_CONTEXT=\"$2\"\n                shift 2\n                ;;\n            --interactive)\n                interactive_mode=true\n                shift\n                ;;\n            --force)\n                force_rollback=true\n                shift\n                ;;\n            --help)\n                echo \"Usage: $0 [options]\"\n                echo \"Options:\"\n                echo \"  --revision REV       Rollback to specific revision\"\n                echo \"  --namespace NS        Kubernetes namespace (default: aurigraph-production)\"\n                echo \"  --context CTX         Kubernetes context (default: production)\"\n                echo \"  --interactive         Interactive rollback mode\"\n                echo \"  --force               Force rollback without confirmation\"\n                echo \"  --help                Show this help message\"\n                echo \"\"\n                echo \"Examples:\"\n                echo \"  $0                           # Rollback to previous revision\"\n                echo \"  $0 --revision 5              # Rollback to revision 5\"\n                echo \"  $0 --interactive             # Interactive rollback selection\"\n                exit 0\n                ;;\n            *)\n                log_error \"Unknown option: $1\"\n                exit 1\n                ;;\n        esac\n    done\n    \n    log_info \"Starting Aurigraph V11 Production Rollback\"\n    log_info \"Timestamp: $TIMESTAMP\"\n    log_info \"Namespace: $NAMESPACE\"\n    log_info \"Kubernetes Context: $KUBE_CONTEXT\"\n    \n    local rollback_start=$(date +%s)\n    \n    # Prerequisites and state capture\n    check_prerequisites\n    capture_current_state\n    \n    # Determine rollback strategy\n    if [[ \"$interactive_mode\" == true ]]; then\n        interactive_rollback\n    elif [[ -n \"$target_revision\" ]]; then\n        log_info \"Rolling back to specified revision: $target_revision\"\n        \n        if [[ \"$force_rollback\" != true ]]; then\n            log_info \"Revision $target_revision details:\"\n            get_revision_info \"$target_revision\"\n            read -p \"Confirm rollback to revision $target_revision? (y/N): \" confirm\n            if [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n                log_info \"Rollback cancelled\"\n                exit 0\n            fi\n        fi\n        \n        rollback_to_revision \"$target_revision\"\n    else\n        log_info \"Rolling back to previous revision...\"\n        \n        if [[ \"$force_rollback\" != true ]]; then\n            local previous_revision\n            previous_revision=$(get_previous_revision)\n            log_info \"Previous revision details:\"\n            get_revision_info \"$previous_revision\"\n            read -p \"Confirm rollback to previous revision $previous_revision? (y/N): \" confirm\n            if [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n                log_info \"Rollback cancelled\"\n                exit 0\n            fi\n        fi\n        \n        rollback_to_previous\n    fi\n    \n    # Post-rollback verification\n    log_info \"Performing post-rollback verification...\"\n    \n    if perform_health_check; then\n        log_success \"Health check passed\"\n    else\n        log_error \"Health check failed after rollback\"\n        send_rollback_notification \"failed\" \"Rollback completed but health check failed - immediate attention required\"\n        exit 1\n    fi\n    \n    if verify_performance; then\n        log_success \"Performance verification passed\"\n    else\n        log_warn \"Performance verification failed - monitoring recommended\"\n    fi\n    \n    local rollback_end=$(date +%s)\n    local rollback_duration=$((rollback_end - rollback_start))\n    \n    # Final status\n    local final_revision\n    final_revision=$(get_current_revision)\n    \n    log_success \"Rollback completed successfully in ${rollback_duration}s\"\n    log_success \"Current revision: $final_revision\"\n    log_success \"Log file: $ROLLBACK_LOG\"\n    \n    # Send success notification\n    send_rollback_notification \"success\" \"Production rollback completed successfully in ${rollback_duration}s to revision $final_revision\" \"$final_revision\"\n    \n    # Display final status\n    echo -e \"\\n${GREEN}=== Rollback Summary ===${NC}\"\n    kubectl get deployment $DEPLOYMENT_NAME -n \"$NAMESPACE\" -o wide\n    echo -e \"\\n${GREEN}=== Pod Status ===${NC}\"\n    kubectl get pods -l app=aurigraph-v11 -n \"$NAMESPACE\" -o wide\n    echo -e \"\\n${GREEN}=== Service Status ===${NC}\"\n    kubectl get service aurigraph-v11-production-service -n \"$NAMESPACE\" -o wide\n}\n\n# Script entry point\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n    main \"$@\"\nfi\n"