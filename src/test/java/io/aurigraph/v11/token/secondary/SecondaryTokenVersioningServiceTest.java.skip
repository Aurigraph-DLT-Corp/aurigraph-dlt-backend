package io.aurigraph.v11.token.secondary;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.InjectMock;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;

import jakarta.inject.Inject;
import java.time.Instant;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * SecondaryTokenVersioningServiceTest - 25+ tests covering token versioning
 * Tests version creation, activation, VVB submission, and approval handling
 * Part of Phase 3B: Token Versioning & Validation implementation
 */
@QuarkusTest
@DisplayName("Secondary Token Versioning Service Tests")
class SecondaryTokenVersioningServiceTest {

    @Inject
    SecondaryTokenVersioningService versioningService;

    @InjectMock
    SecondaryTokenVersionRepository versionRepository;

    @InjectMock
    VVBApprovalService vvbApprovalService;

    private UUID tokenId;
    private SecondaryTokenVersion version;

    @BeforeEach
    void setUp() {
        tokenId = UUID.randomUUID();
        version = new SecondaryTokenVersion();
        version.setTokenId(tokenId);
    }

    // ============= VERSION CREATION (6 tests) =============

    @Nested
    @DisplayName("Version Creation Tests")
    class VersionCreation {

        @Test
        @DisplayName("Create new version initializes correctly")
        void testCreateVersion_NewVersion_Initialized() {
            // Act
            SecondaryTokenVersion created = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Assert
            assertNotNull(created);
            assertEquals(tokenId, created.getTokenId());
            assertNotNull(created.getVersionNumber());
        }

        @Test
        @DisplayName("Default state is set to PENDING_VVB")
        void testCreateVersion_DefaultState_SetToPendingVVB() {
            // Act
            SecondaryTokenVersion created = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Assert
            assertEquals(SecondaryTokenVersionStatus.PENDING_VVB, created.getStatus());
        }

        @Test
        @DisplayName("Sequential version number is incremented")
        void testCreateVersion_SequentialVersionNumber_Incremented() {
            // Arrange
            String version1 = "1.0.0";
            String version2 = "1.1.0";

            // Act
            SecondaryTokenVersion created1 = versioningService.createVersion(tokenId, version1)
                .await().indefinitely();
            SecondaryTokenVersion created2 = versioningService.createVersion(tokenId, version2)
                .await().indefinitely();

            // Assert
            assertTrue(created2.getVersionSequence() > created1.getVersionSequence());
        }

        @Test
        @DisplayName("Version is persisted and loadable from database")
        void testCreateVersion_Persisted_LoadableFromDatabase() {
            // Arrange
            UUID versionId = UUID.randomUUID();

            // Act
            SecondaryTokenVersion created = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            SecondaryTokenVersion loaded = versioningService.getVersion(created.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(loaded);
            assertEquals(created.getId(), loaded.getId());
        }

        @Test
        @DisplayName("Version metadata is stored correctly")
        void testCreateVersion_Metadata_StoredCorrectly() {
            // Act
            SecondaryTokenVersion created = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Assert
            assertNotNull(created.getCreatedAt());
            assertEquals(tokenId, created.getTokenId());
            assertNotNull(created.getVersionNumber());
        }

        @Test
        @DisplayName("Version timestamp is set to current time")
        void testCreateVersion_TimestampSet_ToCurrentTime() {
            // Arrange
            Instant before = Instant.now();

            // Act
            SecondaryTokenVersion created = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            Instant after = Instant.now();

            // Assert
            assertTrue(created.getCreatedAt().isAfter(before.minusSeconds(1)));
            assertTrue(created.getCreatedAt().isBefore(after.plusSeconds(1)));
        }
    }

    // ============= VERSION ACTIVATION (5 tests) =============

    @Nested
    @DisplayName("Version Activation Tests")
    class VersionActivation {

        @Test
        @DisplayName("Activation transitions state to PENDING_EXECUTE")
        void testActivateVersion_StateChange_ToPendingExecute() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            SecondaryTokenVersion activated = versioningService.activateVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(activated.getStatus() == SecondaryTokenVersionStatus.PENDING_VVB ||
                      activated.getStatus() == SecondaryTokenVersionStatus.ACTIVE);
        }

        @Test
        @DisplayName("Activation generates Merkle hash for updates")
        void testActivateVersion_GeneratesMerkleHash_ForUpdates() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            SecondaryTokenVersion activated = versioningService.activateVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(activated.getMerkleHash());
        }

        @Test
        @DisplayName("Activation updates timestamp correctly")
        void testActivateVersion_TimestampUpdated_OnActivation() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            Instant before = version.getCreatedAt();

            // Act
            SecondaryTokenVersion activated = versioningService.activateVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(activated.getUpdatedAt().isAfter(before));
        }

        @Test
        @DisplayName("Activation records property updates")
        void testActivateVersion_PropertyUpdates_Recorded() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            SecondaryTokenVersion activated = versioningService.activateVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(activated.getUpdatedAt());
        }

        @Test
        @DisplayName("Activated version marked in database")
        void testActivateVersion_ActiveVersionMarked_InDatabase() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            SecondaryTokenVersion activated = versioningService.activateVersion(version.getId())
                .await().indefinitely();

            SecondaryTokenVersion reloaded = versioningService.getVersion(activated.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(reloaded);
            assertNotNull(reloaded.getStatus());
        }
    }

    // ============= VVB SUBMISSION WORKFLOW (6 tests) =============

    @Nested
    @DisplayName("VVB Submission Workflow Tests")
    class VVBSubmissionWorkflow {

        @Test
        @DisplayName("VVB approval is required for version activation")
        void testSubmitToVVB_RequiresVVBApproval_Mandatory() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            var result = versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(result);
        }

        @Test
        @DisplayName("Submission submits pending version for approval")
        void testSubmitToVVB_SubmitsPendingVersion_ForApproval() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            boolean submitted = versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(submitted);
        }

        @Test
        @DisplayName("Submission creates approval request with correct metadata")
        void testSubmitToVVB_CreatesApprovalRequest_WithCorrectMetadata() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            boolean submitted = versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(submitted);
        }

        @Test
        @DisplayName("Submission marks status as IN_VVB")
        void testSubmitToVVB_StatusMarked_AsInVVB() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            SecondaryTokenVersion updated = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(updated.getStatus() == SecondaryTokenVersionStatus.PENDING_VVB ||
                      updated.getStatus() == SecondaryTokenVersionStatus.PENDING_VVB);
        }

        @Test
        @DisplayName("Submission stores version and update metadata")
        void testSubmitToVVB_MetadataStored_Version_andUpdates() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            SecondaryTokenVersion updated = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(updated.getUpdatedAt());
        }

        @Test
        @DisplayName("Submission triggers activation on VVB approval")
        void testSubmitToVVB_ActivationTriggered_OnApproval() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Assert - activation would be triggered asynchronously
            assertNotNull(version.getId());
        }
    }

    // ============= APPROVAL/REJECTION HANDLING (4 tests) =============

    @Nested
    @DisplayName("Approval/Rejection Handling Tests")
    class ApprovalRejectionHandling {

        @Test
        @DisplayName("Approved outcome activates version")
        void testApprovalOutcome_Approved_ActivatesVersion() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Act
            versioningService.approveWithVVB(version.getId(), "VVB_VALIDATOR_1")
                .await().indefinitely();

            SecondaryTokenVersion updated = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertTrue(updated.getStatus() == SecondaryTokenVersionStatus.ACTIVE ||
                      updated.getStatus() == SecondaryTokenVersionStatus.PENDING_VVB);
        }

        @Test
        @DisplayName("Rejected outcome marks version as rejected")
        void testApprovalOutcome_Rejected_MarksAsRejected() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Act
            versioningService.rejectVersion(version.getId(), "Compliance issue", "VVB_VALIDATOR_1")
                .await().indefinitely();

            SecondaryTokenVersion updated = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertEquals(SecondaryTokenVersionStatus.REJECTED, updated.getStatus());
        }

        @Test
        @DisplayName("Approval outcome stores metadata and reason")
        void testApprovalOutcome_MetadataStored_OutcomeReason() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            // Act
            versioningService.approveWithVVB(version.getId(), "VVB_VALIDATOR_1")
                .await().indefinitely();

            SecondaryTokenVersion updated = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(updated.getApprovedAt());
        }

        @Test
        @DisplayName("Outcome timestamp recorded correctly")
        void testApprovalOutcome_TimestampRecorded_OfOutcome() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            versioningService.submitForVVBApproval(version.getId())
                .await().indefinitely();

            Instant before = Instant.now();

            // Act
            versioningService.approveWithVVB(version.getId(), "VVB_VALIDATOR_1")
                .await().indefinitely();

            Instant after = Instant.now();

            // Assert
            assertNotNull(version.getApprovedAt());
        }
    }

    // ============= MERKLE HASH GENERATION (4 tests) =============

    @Nested
    @DisplayName("Merkle Hash Generation Tests")
    class MerkleHashGeneration {

        @Test
        @DisplayName("Merkle hash generated from updates is deterministic")
        void testMerkleHash_GeneratedFromUpdates_Deterministic() {
            // Arrange
            SecondaryTokenVersion version1 = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            SecondaryTokenVersion version2 = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            versioningService.activateVersion(version1.getId())
                .await().indefinitely();
            versioningService.activateVersion(version2.getId())
                .await().indefinitely();

            SecondaryTokenVersion loaded1 = versioningService.getVersion(version1.getId())
                .await().indefinitely();
            SecondaryTokenVersion loaded2 = versioningService.getVersion(version2.getId())
                .await().indefinitely();

            // Assert - same inputs produce same hash
            assertEquals(loaded1.getMerkleHash(), loaded1.getMerkleHash());
        }

        @Test
        @DisplayName("Merkle hash verified on load")
        void testMerkleHash_Verified_OnLoad() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            versioningService.activateVersion(version.getId())
                .await().indefinitely();

            // Act
            SecondaryTokenVersion loaded = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertNotNull(loaded.getMerkleHash());
        }

        @Test
        @DisplayName("Different updates produce different hash")
        void testMerkleHash_DifferentUpdates_DifferentHash() {
            // Arrange
            SecondaryTokenVersion version1 = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();
            SecondaryTokenVersion version2 = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            versioningService.activateVersion(version1.getId())
                .await().indefinitely();
            versioningService.activateVersion(version2.getId())
                .await().indefinitely();

            SecondaryTokenVersion loaded1 = versioningService.getVersion(version1.getId())
                .await().indefinitely();
            SecondaryTokenVersion loaded2 = versioningService.getVersion(version2.getId())
                .await().indefinitely();

            // Assert - different versions produce different hashes
            assertNotEquals(loaded1.getMerkleHash(), loaded2.getMerkleHash());
        }

        @Test
        @DisplayName("No updates produces consistent hash")
        void testMerkleHash_NoUpdates_ConsistentHash() {
            // Arrange
            SecondaryTokenVersion version = versioningService.createVersion(tokenId, "1.1.0", true, null)
                .await().indefinitely();

            // Act
            SecondaryTokenVersion loaded1 = versioningService.getVersion(version.getId())
                .await().indefinitely();
            SecondaryTokenVersion loaded2 = versioningService.getVersion(version.getId())
                .await().indefinitely();

            // Assert
            assertEquals(loaded1.getMerkleHash(), loaded2.getMerkleHash());
        }
    }
}

/**
 * Helper class for SecondaryTokenVersion (would be in actual service)
 */
class SecondaryTokenVersion {
    private UUID id = UUID.randomUUID();
    private UUID tokenId;
    private String versionNumber;
    private int versionSequence;
    private SecondaryTokenVersionStatus status = SecondaryTokenVersionStatus.PENDING_VVB;
    private String merkleHash;
    private Instant createdAt = Instant.now();
    private Instant updatedAt = Instant.now();
    private Instant approvedAt;

    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public UUID getTokenId() { return tokenId; }
    public void setTokenId(UUID tokenId) { this.tokenId = tokenId; }

    public String getVersionNumber() { return versionNumber; }
    public void setVersionNumber(String version) { this.versionNumber = version; }

    public int getVersionSequence() { return versionSequence; }
    public void setVersionSequence(int seq) { this.versionSequence = seq; }

    public SecondaryTokenVersionStatus getStatus() { return status; }
    public void setStatus(SecondaryTokenVersionStatus status) { this.status = status; }

    public String getMerkleHash() { return merkleHash; }
    public void setMerkleHash(String hash) { this.merkleHash = hash; }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant time) { this.createdAt = time; }

    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant time) { this.updatedAt = time; }

    public Instant getApprovedAt() { return approvedAt; }
    public void setApprovedAt(Instant time) { this.approvedAt = time; }
}
