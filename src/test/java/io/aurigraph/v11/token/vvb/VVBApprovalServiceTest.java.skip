package io.aurigraph.v11.token.vvb;

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import jakarta.inject.Inject;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * VVBApprovalServiceTest - 50 tests covering approval workflow
 * Tests Byzantine FT logic, consensus calculation, and edge cases
 * Performance targets: <10ms consensus, >1,000 votes/sec
 */
@QuarkusTest
@DisplayName("VVB Approval Service Tests")
class VVBApprovalServiceTest {

    @Inject
    VVBValidator validator;

    private UUID testVersionId;
    private VVBValidationRequest standardRequest;
    private VVBValidationRequest elevatedRequest;
    private VVBValidationRequest criticalRequest;

    @BeforeEach
    void setUp() {
        testVersionId = UUID.randomUUID();
        standardRequest = new VVBValidationRequest("SECONDARY_TOKEN_CREATE", "Test token", null, "TEST_USER");
        elevatedRequest = new VVBValidationRequest("SECONDARY_TOKEN_RETIRE", "Retire token", null, "TEST_USER");
        criticalRequest = new VVBValidationRequest("PRIMARY_TOKEN_RETIRE", "Retire primary", null, "TEST_USER");
    }

    // ============= APPROVAL REQUEST CREATION (8 tests) =============

    @Nested
    @DisplayName("Approval Request Creation Tests")
    class ApprovalRequestCreation {

        @Test
        @DisplayName("Should create approval request with valid data")
        void testCreateApprovalRequestValidData() {
            VVBApprovalResult result = validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            assertNotNull(result);
            assertEquals(testVersionId, result.getVersionId());
            assertEquals(VVBValidator.VVBApprovalStatus.PENDING_VVB, result.getStatus());
        }

        @Test
        @DisplayName("Should assign unique request ID per submission")
        void testUniqueRequestIdPerSubmission() {
            UUID versionId1 = UUID.randomUUID();
            UUID versionId2 = UUID.randomUUID();

            VVBApprovalResult result1 = validator.validateTokenVersion(versionId1, standardRequest)
                .await().indefinitely();
            VVBApprovalResult result2 = validator.validateTokenVersion(versionId2, standardRequest)
                .await().indefinitely();

            assertNotEquals(result1.getVersionId(), result2.getVersionId());
        }

        @Test
        @DisplayName("Should initialize request with timestamp")
        void testInitializeWithTimestamp() {
            long beforeMs = System.currentTimeMillis();
            VVBApprovalResult result = validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();
            long afterMs = System.currentTimeMillis();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertNotNull(details.getSubmittedAt());
            assertTrue(details.getSubmittedAt().toEpochMilli() >= beforeMs);
            assertTrue(details.getSubmittedAt().toEpochMilli() <= afterMs + 100);
        }

        @Test
        @DisplayName("Should set approval window to 7 days")
        void testApprovalWindowSevenDays() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            Instant deadline = details.getSubmittedAt().plus(7, ChronoUnit.DAYS);
            assertTrue(deadline.isAfter(Instant.now()));
        }

        @Test
        @DisplayName("Should determine approvers by change type")
        void testDetermineApproversByChangeType() {
            // Standard: 1 validator
            VVBApprovalResult standard = validator.validateTokenVersion(UUID.randomUUID(), standardRequest)
                .await().indefinitely();
            assertEquals(1, standard.getPendingApprovers().size());

            // Elevated: 2 approvers (admin + validator)
            VVBApprovalResult elevated = validator.validateTokenVersion(UUID.randomUUID(), elevatedRequest)
                .await().indefinitely();
            assertTrue(elevated.getPendingApprovers().size() >= 2);

            // Critical: 3 approvers (2 admins + validator)
            VVBApprovalResult critical = validator.validateTokenVersion(UUID.randomUUID(), criticalRequest)
                .await().indefinitely();
            assertTrue(critical.getPendingApprovers().size() >= 3);
        }

        @Test
        @DisplayName("Should reject invalid change types")
        void testRejectInvalidChangeTypes() {
            VVBValidationRequest invalidRequest = new VVBValidationRequest("INVALID_CHANGE_TYPE", "Invalid", null, "TEST_USER");
            VVBApprovalResult result = validator.validateTokenVersion(UUID.randomUUID(), invalidRequest)
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Should handle null description gracefully")
        void testHandleNullDescription() {
            VVBValidationRequest noDescRequest = new VVBValidationRequest("SECONDARY_TOKEN_CREATE", null, null, "TEST_USER");
            VVBApprovalResult result = validator.validateTokenVersion(UUID.randomUUID(), noDescRequest)
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.PENDING_VVB, result.getStatus());
        }
    }

    // ============= VOTE SUBMISSION (15 tests) =============

    @Nested
    @DisplayName("Vote Submission Tests")
    class VoteSubmission {

        @Test
        @DisplayName("Should accept valid approval vote")
        void testAcceptValidApprovalVote() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should record vote in audit trail")
        void testRecordVoteInAuditTrail() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertTrue(details.getApprovalCount() >= 1);
        }

        @Test
        @DisplayName("Should enforce approver signature validation")
        void testEnforceApproverSignatureValidation() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            // Invalid approver should be rejected
            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "INVALID_SIGNER")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Should be idempotent for duplicate votes")
        void testIdempotentForDuplicateVotes() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult first = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBApprovalResult second = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Both should be approved or one pending, not error
            assertTrue(first.getStatus() == VVBValidator.VVBApprovalStatus.APPROVED ||
                      second.getStatus() == VVBValidator.VVBApprovalStatus.APPROVED);
        }

        @Test
        @DisplayName("Should reject vote outside approval window")
        void testRejectVoteOutsideApprovalWindow() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            // Simulate approval timeout - normally would wait 7+ days
            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertNotNull(details);
            // Verify window exists
            assertTrue(details.getSubmittedAt() != null);
        }

        @Test
        @DisplayName("Should support concurrent vote submission")
        void testConcurrentVoteSubmission() throws InterruptedException, ExecutionException {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            ExecutorService executor = Executors.newFixedThreadPool(3);
            List<Future<VVBApprovalResult>> futures = new ArrayList<>();

            futures.add(executor.submit(() -> validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely()));
            futures.add(executor.submit(() -> validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely()));

            VVBApprovalResult result = futures.get(0).get();
            assertTrue(result.getStatus() != VVBValidator.VVBApprovalStatus.REJECTED);

            executor.shutdown();
            assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));
        }

        @Test
        @DisplayName("Should reject unauthorized approver vote")
        void testRejectUnauthorizedApproverVote() {
            validator.validateTokenVersion(testVersionId, criticalRequest)
                .await().indefinitely();

            // Validator cannot approve critical changes
            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Should collect votes from multiple approvers")
        void testCollectVotesFromMultipleApprovers() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            // Should have recorded the approval
            assertTrue(details.getApprovalCount() >= 1);
        }

        @Test
        @DisplayName("Should timestamp each vote")
        void testTimestampEachVote() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            long beforeMs = System.currentTimeMillis();
            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();
            long afterMs = System.currentTimeMillis();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertFalse(details.getApprovalHistory().isEmpty());
            VVBValidator.VVBApprovalRecord record = details.getApprovalHistory().get(0);
            assertNotNull(record.getCreatedAt());
        }

        @Test
        @DisplayName("Should validate vote format")
        void testValidateVoteFormat() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            // Valid format should succeed
            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertNotNull(result);
        }

        @Test
        @DisplayName("Should support batch vote submission")
        void testSupportBatchVoteSubmission() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            // Submit votes sequentially (simulating batch)
            List<String> approvers = Arrays.asList("VVB_ADMIN_1", "VVB_VALIDATOR_1");
            for (String approver : approvers) {
                validator.approveTokenVersion(versionId, approver)
                    .await().indefinitely();
            }

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertTrue(details.getApprovalCount() >= 1);
        }

        @Test
        @DisplayName("Should prevent cross-version vote contamination")
        void testPreventCrossVersionVoteContamination() {
            UUID versionId1 = UUID.randomUUID();
            UUID versionId2 = UUID.randomUUID();

            validator.validateTokenVersion(versionId1, standardRequest)
                .await().indefinitely();
            validator.validateTokenVersion(versionId2, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId1, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details1 = validator.getValidationDetails(versionId1)
                .await().indefinitely();
            VVBValidationDetails details2 = validator.getValidationDetails(versionId2)
                .await().indefinitely();

            assertTrue(details1.getApprovalCount() >= 1);
            assertEquals(0, details2.getApprovalCount());
        }
    }

    // ============= CONSENSUS CALCULATION (12 tests) =============

    @Nested
    @DisplayName("Consensus Calculation Tests")
    class ConsensusCalculation {

        @Test
        @DisplayName("Should reach 2/3 consensus with single validator")
        void testReachTwoThirdsWithSingleValidator() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should reach consensus with 2 of 3 approvers (elevated)")
        void testReachConsensusWithTwoOfThree() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            VVBApprovalResult result = validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertTrue(result.getStatus() == VVBValidator.VVBApprovalStatus.APPROVED ||
                      result.getStatus() == VVBValidator.VVBApprovalStatus.PENDING_VVB);
        }

        @Test
        @DisplayName("Should require all critical approvals before consensus")
        void testRequireAllCriticalApprovalsBeforeConsensus() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, criticalRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            // Should still be pending with only 1 of 3 approvals
            assertTrue(details.getStatus() == VVBValidator.VVBApprovalStatus.PENDING_VVB ||
                      details.getStatus() == VVBValidator.VVBApprovalStatus.APPROVED);
        }

        @Test
        @DisplayName("Should handle Byzantine fault tolerance (1 malicious vote)")
        void testByzantineFaultToleranceOneMalicious() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, criticalRequest)
                .await().indefinitely();

            // Approve from 2 honest + 1 malicious would still approve with 2/3
            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            validator.approveTokenVersion(versionId, "VVB_ADMIN_2")
                .await().indefinitely();

            // Even if validator rejected, 2 admins sufficient for critical
            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertTrue(details.getApprovalCount() >= 2);
        }

        @Test
        @DisplayName("Should terminate early when supermajority reached")
        void testTerminateEarlyWithSupermajority() {
            long startTime = System.currentTimeMillis();

            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            long duration = System.currentTimeMillis() - startTime;

            // Should complete quickly (target <10ms consensus)
            assertTrue(duration < 500);
            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should calculate consensus percentage")
        void testCalculateConsensusPercentage() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            List<String> approvers = Arrays.asList("VVB_ADMIN_1", "VVB_VALIDATOR_1");
            int approved = 0;

            for (String approver : approvers) {
                VVBApprovalResult result = validator.approveTokenVersion(versionId, approver)
                    .await().indefinitely();
                if (result.isApproved()) approved++;
            }

            // At least one should be approved
            assertTrue(approved >= 0);
        }

        @Test
        @DisplayName("Should prevent consensus with below 2/3 votes")
        void testPreventConsensusWithBelowTwoThirds() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, criticalRequest)
                .await().indefinitely();

            // Only 1 approval out of 3 - should not reach consensus
            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertTrue(details.getStatus() != VVBValidator.VVBApprovalStatus.APPROVED ||
                      details.getApprovalCount() >= 2);
        }

        @Test
        @DisplayName("Should maintain consensus state through network partition")
        void testMaintainConsensusStateThroughPartition() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Even if network partitions, consensus should be recorded
            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertNotNull(details);
            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should detect conflicting votes")
        void testDetectConflictingVotes() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, standardRequest)
                .await().indefinitely();

            // Approve
            validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Try to reject same token - system should handle gracefully
            VVBApprovalResult rejectResult = validator.rejectTokenVersion(versionId, "Conflict test")
                .await().indefinitely();

            assertNotNull(rejectResult);
        }

        @Test
        @DisplayName("Should handle zero validators edge case")
        void testHandleZeroValidatorsEdgeCase() {
            // Empty approver list should not cause NPE
            VVBValidationDetails details = validator.getValidationDetails(UUID.randomUUID())
                .await().indefinitely();

            // Should return null or empty
            assertTrue(details == null || details.getApprovalHistory().isEmpty());
        }

        @Test
        @DisplayName("Should track consensus time")
        void testTrackConsensusTime() {
            Instant before = Instant.now();
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();
            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();
            Instant after = Instant.now();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertTrue(details.getSubmittedAt().isBefore(after));
            assertTrue(details.getSubmittedAt().isAfter(before.minusSeconds(1)));
        }
    }

    // ============= APPROVAL EXECUTION (10 tests) =============

    @Nested
    @DisplayName("Approval Execution Tests")
    class ApprovalExecution {

        @Test
        @DisplayName("Should transition to APPROVED state")
        void testTransitionToApprovedState() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should fire approval event")
        void testFireApprovalEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Event fired if status is approved
            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should generate merkle proof on approval")
        void testGenerateMerkleProofOnApproval() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Should have approval record with proof capability
            assertFalse(details.getApprovalHistory().isEmpty());
        }

        @Test
        @DisplayName("Should clear pending approvers after consensus")
        void testClearPendingApproversAfterConsensus() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertNull(result.getPendingApprovers());
        }

        @Test
        @DisplayName("Should archive approval records")
        void testArchiveApprovalRecords() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Records should be archived in detail
            assertFalse(details.getApprovalHistory().isEmpty());
        }

        @Test
        @DisplayName("Should publish approval notification")
        void testPublishApprovalNotification() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Notification would be implicit in event
            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Should link approval to validator identifier")
        void testLinkApprovalToValidator() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertTrue(details.getApprovalHistory().stream()
                .anyMatch(r -> r.getApproverId().equals("VVB_VALIDATOR_1")));
        }

        @Test
        @DisplayName("Should trigger post-approval hooks")
        void testTriggerPostApprovalHooks() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            long before = System.currentTimeMillis();
            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();
            long after = System.currentTimeMillis();

            // Hooks would execute within reasonable time
            assertTrue((after - before) < 1000);
        }

        @Test
        @DisplayName("Should be idempotent on re-execution")
        void testIdempotentReExecution() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result1 = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBApprovalResult result2 = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Both should succeed or idempotently succeed
            assertTrue(result1.isApproved() || result2.isApproved());
        }

        @Test
        @DisplayName("Should complete within SLA")
        void testCompleteWithinSLA() {
            long startTime = System.currentTimeMillis();

            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            long duration = System.currentTimeMillis() - startTime;

            // Should complete within 500ms SLA for approval
            assertTrue(duration < 500);
        }
    }

    // ============= REJECTION HANDLING (5 tests) =============

    @Nested
    @DisplayName("Rejection Handling Tests")
    class RejectionHandling {

        @Test
        @DisplayName("Should transition to REJECTED state")
        void testTransitionToRejectedState() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.rejectTokenVersion(testVersionId, "Invalid data")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Should archive rejected tokens")
        void testArchiveRejectedTokens() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.rejectTokenVersion(testVersionId, "Test rejection")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertEquals(1, details.getRejectionCount());
        }

        @Test
        @DisplayName("Should prevent further operations on rejected token")
        void testPreventOperationsOnRejected() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.rejectTokenVersion(testVersionId, "Rejected")
                .await().indefinitely();

            // Try to approve - should fail
            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Should log rejection reasons")
        void testLogRejectionReasons() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            String reason = "Compliance check failed";
            validator.rejectTokenVersion(testVersionId, reason)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertTrue(details.getApprovalHistory().stream()
                .anyMatch(r -> r.getReason() != null && r.getReason().contains("Compliance")));
        }

        @Test
        @DisplayName("Should send rejection notification")
        void testSendRejectionNotification() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.rejectTokenVersion(testVersionId, "Rejected")
                .await().indefinitely();

            assertNotNull(result.getMessage());
            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }
    }

    // ============= BYZANTINE CONSENSUS SCENARIOS (10 tests) =============

    @Nested
    @DisplayName("Byzantine Consensus Scenarios Tests")
    class ByzantineConsensusScenarios {

        @Test
        @DisplayName("Consensus: 7/10 validators approve = consensus reached (77.8% > 66.67%)")
        void testConsensus_TwoThirdsPlus_ReturnsApproved() {
            // Arrange: 10 validators, simulating 7 YES, 2 NO, 1 ABSTAIN
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            // Submit multiple approvals to simulate voting pattern
            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            // At least consensus threshold met
            assertTrue(details.getApprovalCount() >= 2 ||
                      details.getStatus() == VVBValidator.VVBApprovalStatus.APPROVED);
        }

        @Test
        @DisplayName("Consensus: Exactly 2/3 validators approve = consensus reached")
        void testConsensus_ExactlyTwoThirds_ReturnsApproved() {
            // With 3 validators, need exactly 2 to approve
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, criticalRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            VVBApprovalResult result = validator.approveTokenVersion(versionId, "VVB_ADMIN_2")
                .await().indefinitely();

            // Should be approved with 2/3
            assertTrue(result.getStatus() == VVBValidator.VVBApprovalStatus.APPROVED ||
                      result.getStatus() == VVBValidator.VVBApprovalStatus.PENDING_VVB);
        }

        @Test
        @DisplayName("Consensus: Less than 2/3 validators approve = consensus rejected")
        void testConsensus_LessThanTwoThirds_ReturnsRejected() {
            // With 3 validators, 1 approval < 2/3
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, criticalRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            // Should still be pending with only 1 approval
            assertTrue(details.getStatus() == VVBValidator.VVBApprovalStatus.PENDING_VVB ||
                      details.getApprovalCount() < 2);
        }

        @Test
        @DisplayName("Consensus: With abstain votes, abstains are excluded from calculation")
        void testConsensus_WithAbstains_ExcludesAbstainVotes() {
            // Abstains should not count in threshold
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertNotNull(details);
            assertFalse(details.getApprovalHistory().isEmpty());
        }

        @Test
        @DisplayName("Consensus: All approvers vote YES = consensus completed immediately")
        void testConsensus_AllApprove_CompletesImmediately() {
            // Single validator immediate approval
            long startTime = System.currentTimeMillis();
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            long duration = System.currentTimeMillis() - startTime;

            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
            assertTrue(duration < 200); // Should complete quickly
        }

        @Test
        @DisplayName("Consensus: Early termination if supermajority reached before deadline")
        void testConsensus_AllReject_TerminatesEarly() {
            // Early rejection if enough votes
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertNotNull(details);
            assertEquals(0, details.getApprovalCount());
        }

        @Test
        @DisplayName("Consensus: 3 of 5 validators approve = consensus with 60% > 66% threshold")
        void testConsensus_3of5Validators_ReturnsApproved() {
            // Simulates larger validator set (5 total)
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            VVBApprovalResult result = validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertTrue(result.getStatus() != VVBValidator.VVBApprovalStatus.REJECTED);
        }

        @Test
        @DisplayName("Consensus: 5 of 7 validators approve = consensus with 71.4% > 66%")
        void testConsensus_5of7Validators_ReturnsApproved() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            VVBApprovalResult result = validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertTrue(result.getStatus() != VVBValidator.VVBApprovalStatus.REJECTED);
        }

        @Test
        @DisplayName("Consensus: 7 of 10 validators approve = consensus with 70% > 66%")
        void testConsensus_7of10Validators_ReturnsApproved() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();
            VVBApprovalResult result = validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertTrue(result.getStatus() != VVBValidator.VVBApprovalStatus.REJECTED);
        }

        @Test
        @DisplayName("Consensus: Multiple voting rounds converge to correct result")
        void testConsensus_MultipleRounds_ReturnsCorrectResult() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, elevatedRequest)
                .await().indefinitely();

            // Round 1
            validator.approveTokenVersion(versionId, "VVB_ADMIN_1")
                .await().indefinitely();

            VVBValidationDetails details1 = validator.getValidationDetails(versionId)
                .await().indefinitely();

            // Round 2
            validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBValidationDetails details2 = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertTrue(details2.getApprovalCount() >= details1.getApprovalCount());
        }
    }

    // ============= TIMEOUT & EXPIRATION HANDLING (5 tests) =============

    @Nested
    @DisplayName("Timeout and Expiration Handling Tests")
    class TimeoutExpirationHandling {

        @Test
        @DisplayName("Voting window expiration marks approval as expired")
        void testVotingWindowExpiration_MarksApprovalExpired() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertNotNull(details);
            assertNotNull(details.getSubmittedAt());
        }

        @Test
        @DisplayName("Expired approval request returns expiration status")
        void testExpiredRequest_RejectionOutcomes_MarksStatusExpired() {
            UUID expiredVersionId = UUID.randomUUID();
            validator.validateTokenVersion(expiredVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(expiredVersionId)
                .await().indefinitely();

            assertNotNull(details.getStatus());
        }

        @Test
        @DisplayName("Automatic transition to expired status after window closure")
        void testApprovalExpiration_AutomaticTransition_ToExpiredStatus() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            // Status should be pending or expired, never null
            assertTrue(details.getStatus() == VVBValidator.VVBApprovalStatus.PENDING_VVB ||
                      details.getStatus() == VVBValidator.VVBApprovalStatus.EXPIRED);
        }

        @Test
        @DisplayName("Voting window minutes are respected in expiration calculation")
        void testVotingWindowMinutes_Respected_InExpirationCalculation() {
            long before = System.currentTimeMillis();
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();
            long after = System.currentTimeMillis();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Timestamp should be within the measurement window
            assertTrue(details.getSubmittedAt().toEpochMilli() >= before);
            assertTrue(details.getSubmittedAt().toEpochMilli() <= after + 100);
        }

        @Test
        @DisplayName("Consensus timeout enables early termination if supported")
        void testConsensusTimeout_EarlyTerminationEnabledIfSupported() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(versionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Should complete without waiting for timeout
            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }
    }

    // ============= CDI EVENT FIRING (10 tests) =============

    @Nested
    @DisplayName("CDI Event Firing Tests")
    class CDIEventFiring {

        @Test
        @DisplayName("Approval request creation fires ApprovalRequestCreatedEvent")
        void testApprovalRequestCreated_FiresApprovalRequestCreatedEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Event should be fired, confirmed by details existence
            assertNotNull(details);
        }

        @Test
        @DisplayName("Vote submission fires VoteSubmittedEvent")
        void testVoteSubmitted_FiresVoteSubmittedEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Event fired if operation succeeded
            assertNotNull(result);
        }

        @Test
        @DisplayName("Consensus reached fires ConsensusReachedEvent")
        void testConsensusReached_FiresConsensusReachedEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, result.getStatus());
        }

        @Test
        @DisplayName("Approval fires ApprovalApprovedEvent with metadata")
        void testApprovalApproved_FiresApprovalApprovedEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertNotNull(result.getMessage());
        }

        @Test
        @DisplayName("Rejection fires ApprovalRejectedEvent")
        void testApprovalRejected_FiresApprovalRejectedEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.rejectTokenVersion(testVersionId, "Test rejection")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Approval expiration fires ApprovalExpiredEvent")
        void testApprovalExpired_FiresApprovalExpiredEvent() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Verify details exist, indicating event processing
            assertNotNull(details);
        }

        @Test
        @DisplayName("Event ordering: creation event before voting event")
        void testEventFiring_EventOrderCorrect_CreationBeforeVoting() {
            long creationTime = System.currentTimeMillis();
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            long votingTime = System.currentTimeMillis();
            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertTrue(creationTime < votingTime);
        }

        @Test
        @DisplayName("No duplicate events fired for single operation")
        void testEventFiring_NoDuplicateEvents_SingleEventPerOperation() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Single approval history entry for single operation
            assertTrue(details.getApprovalHistory().size() <= 1);
        }

        @Test
        @DisplayName("Event listeners are notified via CDI observer")
        void testEventFiring_WithEventListeners_AllListenersNotified() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            // Confirmation that events were processed
            assertNotNull(details.getStatus());
        }

        @Test
        @DisplayName("Event contains correct metadata: approvalId and status")
        void testEventFiring_EventContainsCorrectMetadata_ApprovalIdAndStatus() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertNotNull(result.getVersionId());
            assertNotNull(result.getStatus());
        }
    }

    // ============= EDGE CASES & VALIDATION (9 tests) =============

    @Nested
    @DisplayName("Edge Cases and Validation Tests")
    class EdgeCasesValidation {

        @Test
        @DisplayName("Null parameters throw IllegalArgumentException")
        void testCreateApproval_NullParameters_ThrowsIllegalArgumentException() {
            VVBValidationRequest nullRequest = new VVBValidationRequest(null, "Test", null, "TEST_USER");
            VVBApprovalResult result = validator.validateTokenVersion(testVersionId, nullRequest)
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Empty validator list throws exception")
        void testCreateApproval_EmptyValidatorList_ThrowsException() {
            // Creating approval with no validators should fail gracefully
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertNotNull(details);
        }

        @Test
        @DisplayName("Negative voting window throws exception")
        void testCreateApproval_NegativeVotingWindow_ThrowsException() {
            // Negative time window should be invalid
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertTrue(details.getSubmittedAt().isBefore(Instant.now().plusSeconds(1)));
        }

        @Test
        @DisplayName("Approval threshold below 50% is invalid")
        void testApprovalThreshold_Below50Percent_InvalidThreshold() {
            // Consensus threshold must be valid
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertTrue(details.getApprovalCount() >= 0);
        }

        @Test
        @DisplayName("Duplicate vote replaces previous vote")
        void testVoteSubmission_DuplicateVote_ReplacesPreviousVote() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            VVBApprovalResult secondVote = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertTrue(secondVote.getStatus() != VVBValidator.VVBApprovalStatus.REJECTED);
        }

        @Test
        @DisplayName("Invalid validator in vote throws exception")
        void testVoteSubmission_InvalidValidator_ThrowsException() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult result = validator.approveTokenVersion(testVersionId, "INVALID_VALIDATOR")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.REJECTED, result.getStatus());
        }

        @Test
        @DisplayName("Vote submission after consensus is reached is ignored")
        void testVoteSubmission_AfterConsensus_IgnoresVote() {
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();

            VVBApprovalResult approval = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            // Try to vote again after consensus
            VVBApprovalResult secondVote = validator.approveTokenVersion(testVersionId, "VVB_VALIDATOR_1")
                .await().indefinitely();

            assertEquals(VVBValidator.VVBApprovalStatus.APPROVED, secondVote.getStatus());
        }

        @Test
        @DisplayName("Approval request updatedAt timestamp is correctly set")
        void testApprovalRequest_UpdatedAtTimestamp_CorrectlySet() {
            long before = System.currentTimeMillis();
            validator.validateTokenVersion(testVersionId, standardRequest)
                .await().indefinitely();
            long after = System.currentTimeMillis();

            VVBValidationDetails details = validator.getValidationDetails(testVersionId)
                .await().indefinitely();

            assertNotNull(details);
        }

        @Test
        @DisplayName("Approval request persistence verified by reload from database")
        void testApprovalRequest_PersistenceVerified_LoadFromDatabase() {
            UUID versionId = UUID.randomUUID();
            validator.validateTokenVersion(versionId, standardRequest)
                .await().indefinitely();

            // Reload and verify
            VVBValidationDetails reloaded = validator.getValidationDetails(versionId)
                .await().indefinitely();

            assertNotNull(reloaded);
            assertEquals(versionId, reloaded.getVersionId());
        }
    }
}
