package io.aurigraph.v11.bridge.models;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

/**
 * Bridge Validation Request Model
 * Contains all information needed to validate a cross-chain bridge transaction
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ValidationRequest {

    @JsonProperty("bridgeId")
    private String bridgeId;

    @JsonProperty("sourceChain")
    private String sourceChain;

    @JsonProperty("targetChain")
    private String targetChain;

    @JsonProperty("sourceAddress")
    private String sourceAddress;

    @JsonProperty("targetAddress")
    private String targetAddress;

    @JsonProperty("tokenContract")
    private String tokenContract;

    @JsonProperty("tokenSymbol")
    private String tokenSymbol;

    @JsonProperty("amount")
    private BigDecimal amount;

    @JsonProperty("signature")
    private String signature;

    @JsonProperty("signatureType")
    private String signatureType; // e.g., "SECP256K1", "ED25519"

    @JsonProperty("nonce")
    private Long nonce;

    @JsonProperty("timestamp")
    private Long timestamp;

    @JsonProperty("liquidityCheckRequired")
    private Boolean liquidityCheckRequired; // Default: true

    @JsonProperty("feeCheckRequired")
    private Boolean feeCheckRequired; // Default: true

    @JsonProperty("gasPrice")
    private BigDecimal gasPrice;

    @JsonProperty("maxGasLimit")
    private BigDecimal maxGasLimit;

    @JsonProperty("metadata")
    private String metadata; // Additional data as JSON string

    /**
     * Validate the request has all required fields
     */
    public boolean isValid() {
        return bridgeId != null && !bridgeId.isEmpty() &&
               sourceChain != null && !sourceChain.isEmpty() &&
               targetChain != null && !targetChain.isEmpty() &&
               sourceAddress != null && !sourceAddress.isEmpty() &&
               targetAddress != null && !targetAddress.isEmpty() &&
               tokenContract != null && !tokenContract.isEmpty() &&
               tokenSymbol != null && !tokenSymbol.isEmpty() &&
               amount != null && amount.compareTo(BigDecimal.ZERO) > 0 &&
               signature != null && !signature.isEmpty();
    }

    // Getters generated by Lombok @Data - listed here for IDE and javac clarity
    public String getBridgeId() { return bridgeId; }
    public String getSourceChain() { return sourceChain; }
    public String getTargetChain() { return targetChain; }
    public String getSourceAddress() { return sourceAddress; }
    public String getTargetAddress() { return targetAddress; }
    public String getTokenContract() { return tokenContract; }
    public String getTokenSymbol() { return tokenSymbol; }
    public BigDecimal getAmount() { return amount; }
    public String getSignature() { return signature; }
    public String getSignatureType() { return signatureType; }
    public Long getNonce() { return nonce; }
    public Long getTimestamp() { return timestamp; }
    public Boolean getLiquidityCheckRequired() { return liquidityCheckRequired; }
    public Boolean getFeeCheckRequired() { return feeCheckRequired; }
    public BigDecimal getGasPrice() { return gasPrice; }
    public BigDecimal getMaxGasLimit() { return maxGasLimit; }
    public String getMetadata() { return metadata; }

    /**
     * Get validation errors
     */
    public List<String> getValidationErrors() {
        List<String> errors = new java.util.ArrayList<>();

        if (bridgeId == null || bridgeId.isEmpty()) {
            errors.add("Bridge ID is required");
        }
        if (sourceChain == null || sourceChain.isEmpty()) {
            errors.add("Source chain is required");
        }
        if (targetChain == null || targetChain.isEmpty()) {
            errors.add("Target chain is required");
        }
        if (sourceAddress == null || sourceAddress.isEmpty()) {
            errors.add("Source address is required");
        }
        if (targetAddress == null || targetAddress.isEmpty()) {
            errors.add("Target address is required");
        }
        if (tokenContract == null || tokenContract.isEmpty()) {
            errors.add("Token contract address is required");
        }
        if (tokenSymbol == null || tokenSymbol.isEmpty()) {
            errors.add("Token symbol is required");
        }
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            errors.add("Amount must be greater than zero");
        }
        if (signature == null || signature.isEmpty()) {
            errors.add("Signature is required");
        }
        if (sourceChain.equals(targetChain)) {
            errors.add("Source and target chains cannot be the same");
        }

        return errors;
    }
}
