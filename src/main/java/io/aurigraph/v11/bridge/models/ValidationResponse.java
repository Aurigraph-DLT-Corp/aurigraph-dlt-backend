package io.aurigraph.v11.bridge.models;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Map;

/**
 * Bridge Validation Response Model
 * Contains validation results and detailed information about the bridge transaction
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ValidationResponse {

    @JsonProperty("validationId")
    private String validationId;

    @JsonProperty("status")
    private ValidationStatus status; // SUCCESS, FAILED, WARNINGS

    @JsonProperty("signatureValid")
    private Boolean signatureValid;

    @JsonProperty("liquidityAvailable")
    private Boolean liquidityAvailable;

    @JsonProperty("availableLiquidity")
    private BigDecimal availableLiquidity;

    @JsonProperty("requiredLiquidity")
    private BigDecimal requiredLiquidity;

    @JsonProperty("feeEstimate")
    private BigDecimal feeEstimate;

    @JsonProperty("feeCurrency")
    private String feeCurrency;

    @JsonProperty("gasFeeEstimate")
    private BigDecimal gasFeeEstimate;

    @JsonProperty("totalFeeEstimate")
    private BigDecimal totalFeeEstimate;

    @JsonProperty("estimatedTime")
    private Long estimatedTime; // milliseconds

    @JsonProperty("exchangeRate")
    private BigDecimal exchangeRate;

    @JsonProperty("sourceTokenDecimals")
    private Integer sourceTokenDecimals;

    @JsonProperty("targetTokenDecimals")
    private Integer targetTokenDecimals;

    @JsonProperty("sourceTokenBalance")
    private BigDecimal sourceTokenBalance;

    @JsonProperty("rateLimit")
    private RateLimitInfo rateLimitInfo;

    @JsonProperty("chainCompatibility")
    private Boolean chainCompatibility;

    @JsonProperty("tokenSupported")
    private Boolean tokenSupported;

    @JsonProperty("amountWithinLimits")
    private Boolean amountWithinLimits;

    @JsonProperty("minTransferAmount")
    private BigDecimal minTransferAmount;

    @JsonProperty("maxTransferAmount")
    private BigDecimal maxTransferAmount;

    @JsonProperty("slippagePercentage")
    private BigDecimal slippagePercentage;

    @JsonProperty("validationErrors")
    private List<String> validationErrors;

    @JsonProperty("validationWarnings")
    private List<String> validationWarnings;

    @JsonProperty("validationDetails")
    private Map<String, Object> validationDetails;

    @JsonProperty("timestamp")
    private Instant timestamp;

    @JsonProperty("expiresAt")
    private Instant expiresAt;

    @JsonProperty("nonce")
    private Long nonce;

    // Getters generated by Lombok @Data - listed here for clarity
    public String getValidationId() { return validationId; }
    public ValidationStatus getStatus() { return status; }
    public Boolean getSignatureValid() { return signatureValid; }
    public Boolean getLiquidityAvailable() { return liquidityAvailable; }
    public BigDecimal getAvailableLiquidity() { return availableLiquidity; }
    public BigDecimal getRequiredLiquidity() { return requiredLiquidity; }
    public BigDecimal getFeeEstimate() { return feeEstimate; }
    public String getFeeCurrency() { return feeCurrency; }
    public BigDecimal getGasFeeEstimate() { return gasFeeEstimate; }
    public BigDecimal getTotalFeeEstimate() { return totalFeeEstimate; }
    public Long getEstimatedTime() { return estimatedTime; }
    public BigDecimal getExchangeRate() { return exchangeRate; }
    public Integer getSourceTokenDecimals() { return sourceTokenDecimals; }
    public Integer getTargetTokenDecimals() { return targetTokenDecimals; }
    public BigDecimal getSourceTokenBalance() { return sourceTokenBalance; }
    public RateLimitInfo getRateLimitInfo() { return rateLimitInfo; }
    public Boolean getChainCompatibility() { return chainCompatibility; }
    public Boolean getTokenSupported() { return tokenSupported; }
    public Boolean getAmountWithinLimits() { return amountWithinLimits; }
    public BigDecimal getMinTransferAmount() { return minTransferAmount; }
    public BigDecimal getMaxTransferAmount() { return maxTransferAmount; }
    public BigDecimal getSlippagePercentage() { return slippagePercentage; }
    public List<String> getValidationErrors() { return validationErrors; }
    public List<String> getValidationWarnings() { return validationWarnings; }
    public Map<String, Object> getValidationDetails() { return validationDetails; }
    public Instant getTimestamp() { return timestamp; }
    public Instant getExpiresAt() { return expiresAt; }
    public Long getNonce() { return nonce; }

    /**
     * Check if validation was successful
     */
    public boolean isSuccessful() {
        return status == ValidationStatus.SUCCESS &&
               (signatureValid == null || signatureValid) &&
               (liquidityAvailable == null || liquidityAvailable) &&
               (tokenSupported == null || tokenSupported) &&
               (amountWithinLimits == null || amountWithinLimits) &&
               (chainCompatibility == null || chainCompatibility);
    }

    /**
     * Check if validation has warnings
     */
    public boolean hasWarnings() {
        return status == ValidationStatus.WARNINGS ||
               (validationWarnings != null && !validationWarnings.isEmpty());
    }

    /**
     * Check if validation failed
     */
    public boolean hasFailed() {
        return status == ValidationStatus.FAILED ||
               (validationErrors != null && !validationErrors.isEmpty());
    }

    /**
     * Rate limit information
     */
    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class RateLimitInfo {
        @JsonProperty("requestsPerSecond")
        private Integer requestsPerSecond;

        @JsonProperty("remainingRequests")
        private Integer remainingRequests;

        @JsonProperty("resetTimeSeconds")
        private Integer resetTimeSeconds;

        @JsonProperty("isRateLimited")
        private Boolean isRateLimited;

        // Getters for clarity
        public Integer getRequestsPerSecond() { return requestsPerSecond; }
        public Integer getRemainingRequests() { return remainingRequests; }
        public Integer getResetTimeSeconds() { return resetTimeSeconds; }
        public Boolean getIsRateLimited() { return isRateLimited; }
    }

    /**
     * Validation status enum
     */
    public enum ValidationStatus {
        SUCCESS,    // All validations passed
        WARNINGS,   // Passed but with warnings
        FAILED      // Validation failed
    }
}
