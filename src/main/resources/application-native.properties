# Aurigraph V11 Native Build Configuration
# SPARC Week 1 Day 3-5: Native Optimization for 8.51M TPS Target
#
# JFR Analysis Baseline:
# - JVM Mode: 635K TPS (776K optimized)
# - Virtual threads: 56% CPU overhead, 89 min wait time
# - Allocation rate: 9.4 MB/s
#
# Native Mode Targets:
# - TPS: 8.51M (13.4x improvement)
# - CPU overhead: <5%
# - Allocation rate: <4 MB/s
# - Thread wait time: <5 min
# - Startup: <500ms
# - Memory: <128MB

# ==================== APPLICATION IDENTITY ====================
quarkus.application.name=aurigraph-v11-native
quarkus.application.version=11.4.4-native

# ==================== HTTP CONFIGURATION ====================
# Production settings (HTTPS termination via NGINX)
quarkus.http.port=9003
quarkus.http.host=0.0.0.0
quarkus.http.http2=true
quarkus.http.insecure-requests=enabled
quarkus.http.ssl-port=0

# HTTP/2 Ultra-Optimized for Native
quarkus.http.limits.max-concurrent-streams=200000
quarkus.http.limits.max-frame-size=16777215
quarkus.http.limits.max-header-size=65536
quarkus.http.limits.max-chunk-size=16384
quarkus.http.io-threads=8

# ==================== NATIVE THREAD POOL CONFIGURATION ====================
# SPARC Week 1 Optimization: ForkJoinPool for native builds
# Replaces virtual threads to eliminate 56% CPU overhead

# Enable native mode (uses ForkJoinPool instead of ThreadPoolExecutor)
aurigraph.thread.pool.native.mode=true

# ForkJoinPool parallelism (0 = auto-detect: 2 * CPU cores)
# Recommended: 2x to 4x CPU cores for optimal throughput
aurigraph.thread.pool.forkjoin.parallelism=0

# Async mode: true for FIFO scheduling (better throughput)
# false for LIFO scheduling (better locality)
aurigraph.thread.pool.forkjoin.async.mode=true

# Fallback platform thread pool settings (JVM mode)
aurigraph.thread.pool.size=256
aurigraph.thread.pool.queue.size=500000
aurigraph.thread.pool.keep.alive.seconds=60
aurigraph.thread.pool.metrics.enabled=true

# ==================== CONSENSUS CONFIGURATION ====================
# Optimized for native execution: larger batches, more parallelism
consensus.node.id=aurigraph-native-node-1
consensus.validators=aurigraph-native-node-1,aurigraph-native-node-2,aurigraph-native-node-3
consensus.batch.size=200000
consensus.pipeline.depth=60
consensus.parallel.threads=1024
consensus.target.tps=8510000
consensus.election.timeout.ms=250
consensus.heartbeat.interval.ms=20

# ==================== AI OPTIMIZATION CONFIGURATION ====================
# Aggressive AI tuning for native performance
ai.optimization.enabled=true
ai.optimization.target.tps=8510000
ai.optimization.learning.rate=0.00005
ai.optimization.model.update.interval.ms=2000
ai.optimization.prediction.window.ms=1000
ai.optimization.anomaly.threshold=0.95
ai.optimization.min.confidence=0.85

# AI module enable flags
ai.consensus.optimizer.enabled=true
ai.predictive.ordering.enabled=true
ai.anomaly.detection.enabled=true
ai.adaptive.batching.enabled=true

# ==================== BATCH PROCESSING ====================
# Ultra-large batches for native throughput
batch.processor.enabled=true
batch.processor.min.size=5000
batch.processor.max.size=500000
batch.processor.default.size=200000
batch.processor.timeout.ms=500
batch.processor.adaptation.interval.ms=250
batch.processor.parallel.workers=1024
batch.processor.compression.enabled=true

# ==================== MEMORY OPTIMIZATION ====================
# Lock-free, zero-copy memory structures for native
aurigraph.memory.pool.enabled=true
aurigraph.memory.pool.size.mb=16384
aurigraph.memory.pool.segments=1024
aurigraph.memory.pool.allocation.strategy=LOCK_FREE
aurigraph.memory.pool.prealloc=true
aurigraph.memory.pool.huge.pages=true

# SIMD and CPU optimizations
aurigraph.simd.enabled=true
aurigraph.simd.vector.size=512
aurigraph.cache.line.size=64
aurigraph.cache.prefetch=true
aurigraph.numa.aware=true
aurigraph.numa.interleave=true
aurigraph.cpu.affinity.enabled=true
aurigraph.cpu.cores=16
aurigraph.cpu.worker.threads=1024

# Lock-free data structures
aurigraph.lockfree.enabled=true
aurigraph.lockfree.retry.limit=1000
aurigraph.lockfree.backoff.strategy=EXPONENTIAL

# ==================== ULTRA PERFORMANCE MODE ====================
aurigraph.ultra.performance.mode=true
aurigraph.transaction.shards=8192
aurigraph.batch.size.optimal=200000
aurigraph.batch.size.max=200000
aurigraph.processing.parallelism=4096
aurigraph.cache.size.max=100000000

# xxHash optimization (10x faster than SHA-256)
xxhash.optimization.enabled=true

# ==================== VIRTUAL THREADS (DISABLED FOR NATIVE) ====================
# Virtual threads cause 56% CPU overhead - disabled for native builds
quarkus.virtual-threads.enabled=false

# Platform thread pool for Quarkus runtime
quarkus.thread-pool.core-threads=256
quarkus.thread-pool.max-threads=1024
quarkus.thread-pool.queue-size=100000

# ==================== LEVELDB CONFIGURATION ====================
leveldb.data.path=/var/lib/aurigraph/leveldb/native-node
leveldb.cache.size.mb=1024
leveldb.write.buffer.mb=256
leveldb.compression.enabled=true
leveldb.max.open.files=10000
leveldb.block.size.kb=64
leveldb.bloom.filter.bits=10

# ==================== DATABASE CONFIGURATION ====================
# Minimal database usage for native performance
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=aurigraph
quarkus.datasource.password=aurigraph2025
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/aurigraph_demos
quarkus.datasource.jdbc.max-size=50
quarkus.datasource.jdbc.min-size=10
quarkus.hibernate-orm.database.generation=update
quarkus.hibernate-orm.log.sql=false

# ==================== LOGGING ====================
# Minimal logging for maximum performance
quarkus.log.level=INFO
quarkus.log.category."io.aurigraph".level=INFO
quarkus.log.category."io.aurigraph.v11.performance".level=DEBUG
quarkus.log.console.json=false
quarkus.log.console.format=%d{HH:mm:ss} %-5p [NATIVE][%c{2.}] %s%e%n

# Disable file logging for native (performance)
quarkus.log.file.path=

# ==================== METRICS & MONITORING ====================
quarkus.micrometer.enabled=true
quarkus.micrometer.export.prometheus.enabled=true
quarkus.smallrye-health.root-path=/q/health

# ==================== CORS ====================
quarkus.http.cors=true
quarkus.http.cors.origins=https://dlt.aurigraph.io
quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
quarkus.http.cors.headers=Content-Type,Authorization,X-Requested-With,Accept,Origin

# ==================== QUANTUM CRYPTOGRAPHY ====================
# NIST Level 5 for production security
aurigraph.crypto.quantum.enabled=true
aurigraph.crypto.quantum.nist-level=5
aurigraph.crypto.kyber.security-level=5
aurigraph.crypto.dilithium.security-level=5
aurigraph.crypto.sphincs.security-level=5

# ==================== NATIVE BUILD OPTIMIZATIONS ====================
# These are hints for native compilation (actual settings in pom.xml)
# Startup target: <500ms
# Memory target: <128MB
# Binary size target: <150MB

# GC Settings (applied during native build)
# -H:+UseG1GC -H:MaxGCPauseMillis=1 -H:G1HeapRegionSize=64m

# CPU Optimizations (applied during native build)
# -march=native -O3

# Comments:
# This configuration is specifically tuned for native compilation.
# Expected performance improvements over JVM mode:
# - 13.4x TPS improvement (635K → 8.51M)
# - 11x reduction in CPU overhead (56% → 5%)
# - 2.4x reduction in memory allocation (9.4 → 4 MB/s)
# - 17.8x reduction in thread wait time (89 min → 5 min)
# - 6x faster startup (<500ms vs 3s JVM)
# - 4x lower memory footprint (<128MB vs 512MB JVM)
