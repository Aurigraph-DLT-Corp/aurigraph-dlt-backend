# Aurigraph V11 Performance Testing Profile
# Optimized for 2M+ TPS benchmarking
# Usage: ./mvnw quarkus:dev -Dquarkus.profile=perf

# ================================
# Application Identity
# ================================
quarkus.application.name=aurigraph-v11-performance
quarkus.application.version=11.0.0

# ================================
# HTTP/2 Ultra-Performance Configuration
# ================================
quarkus.http.port=9003
quarkus.http.host=0.0.0.0
quarkus.http.http2=true

# HTTP/2 Limits - Optimized for 2M+ TPS
quarkus.http.limits.max-concurrent-streams=100000
quarkus.http.limits.max-frame-size=16777215
quarkus.http.limits.initial-window-size=2097152
quarkus.http.limits.max-header-size=65536
quarkus.http.limits.max-chunk-size=16384

# Advanced TCP Optimizations
quarkus.http.so-reuse-port=true
quarkus.http.tcp-quick-ack=true
quarkus.http.tcp-cork=true
quarkus.http.tcp-fast-open=true
quarkus.http.tcp-no-delay=true

# ================================
# gRPC High-Performance Configuration
# ================================
quarkus.grpc.server.port=9004
quarkus.grpc.server.host=0.0.0.0
quarkus.grpc.server.use-separate-server=true
quarkus.grpc.server.max-inbound-message-size=33554432
quarkus.grpc.server.max-inbound-metadata-size=65536

grpc.max-concurrent-streams=50000
grpc.initial-window-size=2097152
grpc.max-frame-size=16777215

# ================================
# Consensus Configuration - Production Scale
# ================================
consensus.node.id=aurigraph-perf-test-node-1
consensus.batch.size=50000
consensus.parallel.threads=512
consensus.target.tps=2500000
consensus.pipeline.depth=50
consensus.election.timeout.ms=500
consensus.heartbeat.interval.ms=50

# Consensus Network Optimization
consensus.network.compression=true
consensus.network.encryption=false
consensus.network.buffer.size=16777216
consensus.network.batch.timeout.ms=5

# ================================
# AI Optimization - Aggressive Tuning
# ================================
ai.optimization.enabled=true
ai.optimization.target.tps=3000000
ai.optimization.learning.rate=0.0001
ai.optimization.model.update.interval.ms=3000
ai.optimization.prediction.window.ms=1000
ai.optimization.anomaly.threshold=0.95
ai.optimization.min.confidence=0.85

# Predictive Routing
routing.prediction.enabled=true
routing.prediction.window.ms=500
routing.load.balance.threshold=0.85
routing.congestion.threshold=0.80
routing.node.count=5
routing.prediction.accuracy.target=0.95

# Anomaly Detection
anomaly.detection.enabled=true
anomaly.detection.sensitivity=0.95
anomaly.detection.window.size=5000
anomaly.detection.update.interval.ms=2500
anomaly.detection.alert.threshold=0.90

# ML Load Balancer
ml.loadbalancer.enabled=true
ml.loadbalancer.algorithm=DEEP_REINFORCEMENT_LEARNING
ml.loadbalancer.rebalance.interval.ms=2500
ml.loadbalancer.resource.count=16
ml.loadbalancer.learning.rate=0.005

# Adaptive Batch Processor
batch.processor.enabled=true
batch.processor.min.size=1000
batch.processor.max.size=200000
batch.processor.default.size=50000
batch.processor.timeout.ms=2500
batch.processor.adaptation.interval.ms=1000
batch.processor.parallel.workers=256
batch.processor.compression.enabled=true

# ================================
# LevelDB High-Performance Configuration
# ================================
# Path for performance testing
leveldb.data.path=./data/leveldb/perf-test-node

# Ultra-High-Performance Cache Settings
leveldb.cache.size.mb=1024
leveldb.write.buffer.mb=256

# Advanced LevelDB Tuning
leveldb.compression.enabled=true
leveldb.max.open.files=10000
leveldb.block.size.kb=64
leveldb.bloom.filter.bits=10
leveldb.compression.type=snappy

# ================================
# Transaction Processing - Ultra Performance
# ================================
aurigraph.transaction.shards=512
aurigraph.batch.size.optimal=100000
aurigraph.processing.parallelism=1024
aurigraph.virtual.threads.max=200000
aurigraph.cache.size.max=10000000
aurigraph.ultra.performance.mode=true

# Cache Configuration
aurigraph.cache.eviction.policy=LRU
aurigraph.cache.ttl.seconds=3600

# Memory-Mapped Transaction Pool - Large Scale
aurigraph.memory.pool.enabled=true
aurigraph.memory.pool.size.mb=4096
aurigraph.memory.pool.segments=256
aurigraph.memory.pool.allocation.strategy=LOCK_FREE_ATOMIC

# SIMD and Cache Optimization
aurigraph.simd.enabled=true
aurigraph.simd.vector.width=512
aurigraph.cache.line.size=64
aurigraph.numa.aware=true
aurigraph.cpu.affinity.enabled=true

# Lock-Free Data Structures
aurigraph.lockfree.enabled=true
aurigraph.lockfree.retry.limit=10000
aurigraph.lockfree.backoff.strategy=ADAPTIVE_EXPONENTIAL

# ================================
# Virtual Threads (Java 21) - Maximum Concurrency
# ================================
quarkus.virtual-threads.enabled=true
quarkus.virtual-threads.name-pattern=aurigraph-perf-vt-#
quarkus.virtual-threads.max-pooled=1000000
quarkus.virtual-threads.executor.max-threads=1000000
quarkus.virtual-threads.shutdown-timeout=60

# ================================
# Database Configuration
# ================================
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=aurigraph_perf
quarkus.datasource.password=perf_password
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/aurigraph_demos
quarkus.datasource.jdbc.max-size=100
quarkus.datasource.jdbc.min-size=10
quarkus.hibernate-orm.database.generation=update

# ================================
# Logging - Performance Monitoring
# ================================
quarkus.log.level=INFO
quarkus.log.category."io.aurigraph".level=INFO
quarkus.log.category."io.aurigraph.v11.performance".level=DEBUG
quarkus.log.console.enable=true
quarkus.log.console.format=%d{HH:mm:ss} %-5p [PERF][%c{2.}] %s%e%n

# Disable file logging for performance
quarkus.log.file.enable=false

# ================================
# Metrics & Monitoring
# ================================
quarkus.micrometer.enabled=true
quarkus.micrometer.export.prometheus.enabled=true
quarkus.micrometer.export.prometheus.path=/q/metrics

# Health Checks
quarkus.smallrye-health.root-path=/q/health

# ================================
# CORS Configuration
# ================================
quarkus.http.cors=true
quarkus.http.cors.origins=*
quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
quarkus.http.cors.headers=Content-Type,Authorization,X-Requested-With

# ================================
# Performance Testing Specific
# ================================

# Disable security overhead for testing
quarkus.http.ssl-port=0
quarkus.http.insecure-requests=enabled

# Disable gRPC TLS for testing
quarkus.grpc.server.plain-text=true

# Test Configuration
quarkus.test.continuous-testing=disabled

# ================================
# HMS Performance Settings
# ================================
hms.performance.target.tps=200000
hms.tokenization.batch.size=10000
hms.connection.pool.size=50

# ================================
# Comments
# ================================
# This profile is designed for performance testing and benchmarking
# It uses aggressive settings optimized for maximum throughput
#
# Expected Performance:
# - Target TPS: 2.5M - 3M
# - P99 Latency: <100ms
# - Memory: ~1-2GB
# - Virtual Threads: Up to 1M concurrent
#
# Usage:
#   ./mvnw quarkus:dev -Dquarkus.profile=perf
#   ./performance-benchmark.sh
#
# Warning: Not for production use without proper security hardening
